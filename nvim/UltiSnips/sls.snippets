# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# Jinja
extends jinja

# Salt
snippet s "Call a Salt function"
salt['${1:pillar.get}'](${2:args})
endsnippet

snippet p "Get a Pillar value"
salt['pillar.get']('${1:key}'${2/.+/, /}${2:default})
endsnippet

snippet c "Get a config/pillar value"
salt['config.get']('${1:key}'${2/.+/, /}${2:default})
endsnippet

snippet g "Grains value"
salt['grains.get']('${1:key}')
endsnippet

snippet include "The include statement" b
include:
	- $0
endsnippet

snippet exclude "The exclude statement" b
exclude:
	- ${1:sls}: ${2:name}
endsnippet

snippet extend "The extend statement" b
extend:
	${1:id_to_extend}:
		${2:module_name}:
			- ${3:key}: 
endsnippet

snippet /^(\s*)- ?n(a|am|ame|ame:)?/ "State name" r
`!p snip.rv = match.group(1)`- name: ${VISUAL}
endsnippet

# Requisites
snippet require "Demands that the required state executes before"
require:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet require_any "Demands that one of the required states executes before the dependent state"
require_any:
	- ${1:${2:file}: ${3:state_id}}
	- ${4:${5:file}: ${6:state_id}}
endsnippet

snippet require_in "Demands that the required state executes before"
require_in:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet watch "Add additional behavior when there are changes"
watch:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet watch_any "Add additional behavior when there are changes in any states"
watch_any:
	- ${1:${2:file}: ${3:state_id}}
	- ${4:${5:file}: ${6:state_id}}
endsnippet

snippet watch_in "Add additional behavior when there are changes"
watch_in:
	- ${1:${2:service}: ${3:state_id}}
endsnippet

snippet prereq "Actions to be taken based on the expected results of a state that has not yet been executed"
prereq:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet prereq_in "Actions to be taken based on the expected results of a state that has not yet been executed"
prereq_in:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet use "Inherit the arguments passed in another id declaration"
use:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet use_in "Inherit the arguments passed in another id declaration"
use_in:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet onchanges "Makes a state only apply if the required states generate changes"
onchanges:
	- ${1:${2:file}: ${3:state_id}}
endsnippet

snippet onchanges_any "Makes a state only apply if one of the required states generates changes"
onchanges_any:
	- ${1:${2:file}: ${3:state_id}}
	- ${4:${5:file}: ${6:state_id}}
endsnippet

snippet onchanges_in "Makes a state only apply if the required states generate changes"
onchanges_in:
	- ${1:${2:service}: ${3:state_id}}
endsnippet

snippet onfail "Make a state only apply as a response to the failure of another state"
onfail:
	- ${1:${2:service}: ${3:state_id}}
endsnippet

snippet onfail_any "Make a state only apply as a response to the failure of at least one other state"
onfail_any:
	- ${1:${2:service}: ${3:state_id}}
endsnippet

snippet onfail_in "Make a state only apply as a response to the failure of another state"
onfail_in:
	- ${1:${2:service}: ${3:state_id}}
endsnippet

snippet runas "Set the user which will be used to run the command"
runas: ${1:user}
endsnippet

snippet fire_event "Send an event to the Salt Master upon completion of that individual state"
fire_event: ${1:True}
endsnippet

snippet reload_modules "Reload modules"
reload_modules: True
endsnippet

snippet reload_grains "Reload Grains"
reload_grains: True
endsnippet

snippet reload_pillar "Reload Pillar"
reload_pillar: True
endsnippet

snippet unless "State should only run when any of the specified commands return False"
unless:
	- ${1:fun: ${2:file.file_exists}}
endsnippet

snippet onlyif "If each command listed in onlyif returns True, then the state is run"
onlyif:
	- ${1:fun: ${2:file.file_exists}}
endsnippet

snippet check_cmd "Determine that a state did or did not run as expected"
check_cmd:
	- ${1:cmd}
endsnippet

snippet retry "Execute a state multiple times until a desired result is obtained"
retry: True
endsnippet

snippet retry "Execute a state multiple times until a desired result is obtained"
retry:
	attempts: ${1:5}
	interval: ${2:30}
	splay: ${3:10}
endsnippet

snippet backup "Backing up files that are replaced by the file.managed and file.recurse states"
backup: minion
endsnippet

# Formulas snippets
snippet import_map "Import from map.jinja" b
{#- Get the \`tplroot\` from \`tpldir\` #}
{%- set tplroot = tpldir.split('/')[0] %}
{%- from tplroot ~ "/map.jinja" import ${1:`!p
s=re.search('.*(?:salt|[^/]*formula[^/]*)/([^/]+)', path)
snip.rv=s.group(1) if s else 'name' `} with context %}
endsnippet

snippet tplroot "Get the tplroot from tpldir" b
{#- Get the \`tplroot\` from \`tpldir\` #}
{%- set tplroot = tpldir.split('/')[0] %}
endsnippet

snippet import_files_switch "Import files_switch" b
{%- from tplroot ~ "/libtofs.jinja" import files_switch with context %}
endsnippet

snippet files_switch "source: files_switch"
{{ files_switch(['${1:${2:`!p
s=re.search('.*(?:salt|[^/]*formula[^/]*)/([^/]+)', path)
snip.rv=s.group(1) if s else 'name' `}.conf}'],
                          lookup='${3:`!p
s=re.search('.*(?:salt|[^/]*formula[^/]*)/([^/]+)', path)
snip.rv=s.group(1)+'-config-file-managed' if s else 'name-config-file-managed' `}'
             )
          }}
endsnippet

# States
snippet test.nop "A no-op state that does nothing" b
test.nop: []
endsnippet

snippet file.replace "Maintain an edit in a file" b
file.replace:
	- name: ${1:/path/to/file}
	- pattern: ${2:match_regexp}
	- repl: ${3:replacement_text}
endsnippet

snippet service.running "Ensure that the service is running" b
service.running:
	- name: ${1:service_name}
	- enable: ${2:yes}
	- reload: ${3:yes}
endsnippet

snippet file.managed "Manage a given file" b
file.managed:
	- name: ${1:\{\{ `!p s=re.search('.*(?:salt|[^/]*formula[^/]*)/([^/]+)', path)
snip.rv=s.group(1) if s else '/path/to/file' `.config \}\}}
	- source: ${2:salt://${3:`!p
s=re.search('.*(?:salt|[^/]*formula[^/]*)/([^/]+)', path)
snip.rv=s.group(1) if s else 'name' `/files/${4:config}}}
	- user: ${5:root}
	- group: ${6:root}
	- mode: ${7:644}
	- makedirs: ${8:yes}
	- template: ${9:jinja}
	- context:
			`!p s=re.search('.*(?:salt|[^/]*formula[^/]*)/([^/]+)', path)
v=s.group(1) if s else 'name'
snip.rv='{}: {{{{ {}|yaml }}}}'.format(v, v) `
endsnippet

snippet file.serialize "Serializes dataset and store it into managed file" b
file.serialize:
	- name: ${1:file_path}
	- dataset: ${2:\{\{ ${3:data} | yaml \}\}}
	- formatter: ${4:configparser}
	- user: ${5:root}
	- group: ${6:root}
	- mode: ${7:644}
	- makedirs: ${8:yes}
endsnippet

snippet pkg.installed "Ensure that the package is installed" b
pkg.installed:
	- name: ${1:package_name}
endsnippet

snippet pkg.installed.pkgs "Ensure that multiple packages are installed" b
pkg.installed:
	- pkgs:$1
endsnippet

snippet pkg.removed "Verify that a package is not installed" b
pkg.removed:
	- name: ${1:package_name}
endsnippet

snippet pkg.removed.pkg "Verify that list of packages is removed" b
pkg.removed:
	- pkgs:$1
endsnippet

snippet pkg.purged "Verify that a package is purged" b
pkg.purged:
	- name: ${1:package_name}
endsnippet

snippet pkg.purged.pkg "Verify that list of packages is purged" b
pkg.purged:
	- pkgs:$1
endsnippet
